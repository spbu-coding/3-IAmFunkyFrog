В ходе эксперимента было выявлено, что точности типа данных float недостаточно, чтобы сократить отклонение текущего решения от решения системы в примере 4 до 10^(-6) и при этом получить корректные результаты.

 Experiment: 10
Answer in floats x1: 1.001026153564453125 x2: 0.998973846435546875
Delta answer in floats x1: 0.998641967773437500 x2: 1.001358032226562500
Delta in floats: 0.000000195312495066 Distance in floats: 0.0033717479091138
Answer in doubles x1: 0.999999999997889688 x2: 1.000000000002110312
Delta answer in doubles x1: 0.998046874998379963 x2: 1.001953125001620037
Delta in doubles: 0.000000195312500000 Distance in doubles: 0.0027621358633166

 Experiment: 11
Answer in floats x1: 1.001026153564453125 x2: 0.998973846435546875
Delta answer in floats x1: 1.001026153564453125 x2: 0.998973846435546875
Delta in floats: 0.000000097656247533 Distance in floats: 0.0000000000000000
Answer in doubles x1: 0.999999999997889688 x2: 1.000000000002110312
Delta answer in doubles x1: 0.999023437495914379 x2: 1.000976562504085621
Delta in doubles: 0.000000097656250000 Distance in doubles: 0.0013810679347985

Из 10 и 11 итерациий эксперимента видно, что при величине отклонения в (Delta in floats: 0.00000009765624753) текущего решения от решения системы с дельтой равняется (Distance in floats: 0.0000000000000000), из чего можно сделать вывод, что float не хватает точности, чтобы различить эти два решения.

 Experiment: 21
Answer in floats x1: 1.001026153564453125 x2: 0.998973846435546875
Delta answer in floats x1: 1.001026153564453125 x2: 0.998973846435546875
Delta in floats: 0.000000000095367429 Distance in floats: 0.0000000000000000
Answer in doubles x1: 0.999999999997889688 x2: 1.000000000002110312
Delta answer in doubles x1: 0.999999046325193319 x2: 1.000000953674806681
Delta in doubles: 0.000000000095367432 Distance in doubles: 0.0000013486968613

 Experiment: 22
Answer in floats x1: 1.001026153564453125 x2: 0.998973846435546875
Delta answer in floats x1: 1.001026153564453125 x2: 0.998973846435546875
Delta in floats: 0.000000000047683715 Distance in floats: 0.0000000000000000
Answer in doubles x1: 0.999999999997889688 x2: 1.000000000002110312
Delta answer in doubles x1: 0.999999523161541504 x2: 1.000000476838458496
Delta in doubles: 0.000000000047683716 Distance in doubles: 0.0000006743484306

Что же касается типа double, видно, что спустя 22 итерации отклонение текущего решения от решения системы с дельтой меньше 10^(-6), и при этом решения различны, несмотря на небольшую погрешность в вычислениях.

Таким образом, тип double обеспечивает нас достаточной точностью для выполнения нашей задачи, в отличие от типа float.

Дополнение (по experiment_2):

Описанный выше эксперимент проводился, используя такую формулу для вычисления ответов:

answerf.x2 = (deltaf + 2.0001f - 2.0f) / 0.0001f;
answerf.x1 = 2.0f - answerf.x2;

Где deltaf - величина отклонения, однако если эту формулу изменить:

answerf.x2 = (deltaf + 0.0001f) / 0.0001f;
answerf.x1 = 2.0f - answerf.x2

тогда точности типа float хватит, чтобы сократить отклонение текущей системы решений от отклонения системы с дельтой до необходимого значения 10^(-6). Насколько мне удалось выяснить, такой интересный эффект достигается за счет того, что все вычисления начинают происходить в меньших порядках, в которых количества значащих цифр, которое может обеспечить тип float (7-8 согласно английский вики по запросу Single-precision floating-point format), достаточно.
